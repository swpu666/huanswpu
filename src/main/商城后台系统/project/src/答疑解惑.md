<!-- 1.promise相关： -->
根本目的解决异步的回调地狱（传统的JavaScript是一个单线程的为了实现异步问题，则需要通过定时器和回调函数来实现，当回调函数多层嵌套就会出现回调地狱,见下方）

<!-- 
setTimeout(() => {
    console.log("hello");
  
  setTimeout(() => {
      console.log("world");
  
    setTimeout(() => {
      console.log("2");
    }, 400);
  }, 300);
}, 200); 
-->
promise正如其名：代表一个承诺，承诺请求会在未来返回数据
fetch会返回一个promise对象
fetch("url").then《如果成功返回结果》((response(这是请求结果))=>{

}).catch《失败调用》((error)=>{

}).finally《无论成功与否都会调用》(()=>{

})
<!-- async : -->
标记函数为异步函数（返回值为promise对象的函数如上文的fetch）
async function f(){
  在异步函数中调用其他的异步函数，不在需要then
  而需要await，其会等待promise完成之后直接返回最终结果，如下的response就是服务器返回的数据
    const response= await fetch("url") 
    最好不要写多个await ,因为后一个await会等待第一个await执行完才执行影响效率而需要
    const [a,b]=await Promise.all([promiseA,promiseB])

    await外使用foreach函数不会等到执行完才返回，而会在一个执行完就返回，所以自己用fori循环
}

resolve(res) 将promise的状态变为成功，并且打印res
之后执行then



<!-- 2.ajax,fetch,axios: -->
https://juejin.cn/post/7086325194934976519

Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。

Fetch 是一个 API，它是真实存在的，它是基于 promise 的。
Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象。它是 XMLHttpRequest 的替代品。
Axios 是一个基于 promise 封装的网络请求库，它是基于 XHR 进行二次封装。



<!-- 3.flex布局： -->
   弹性布局
   通用的（无论行内还是其他）
   当我们把父元素设置为flex布局后，子元素的float，clear和vertical-align失效
   flex元素的所有子元素自动成为fle元素的容器成员
   通过给父元素添加flex布局来控制子盒子位置和排列方式
   容器属性

<!-- 1、css flex-direction -->

flex-direction属性决定主轴的方向（即项目的排列方向）
flex-direction: row | row-reverse | column | column-reverse
row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。

<!-- 2、css flex-wrap（换行） -->

flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行.
flex-wrap: nowrap | wrap | wrap-reverse;
nowrap（默认）：不换行。
wrap：换行，第一行在上方。
wrap-reverse：换行，第一行在下方。

<!-- 3、css flex-flow -->

flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
flex-flow: <flex-direction> || <flex-wrap>;

<!-- 4、justify-content -->

justify-content属性定义了项目在主轴上的对齐方式。
justify-content: flex-start | flex-end | center | space-between | space-around;
flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，项目之间的间隔都相等。
space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

<!-- 5、align-items -->

align-items属性定义项目在交叉轴上如何对齐。
align-items: flex-start | flex-end | center | baseline | stretch;
flex-start：交叉轴的起点对齐。
flex-end：交叉轴的终点对齐。
center：交叉轴的中点对齐。
baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

<!-- 6、align-content -->

align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用.
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。


<!-- 4.插槽： -->
5.rem:相对于根元素的字体大小“16px”：


<!-- 6.transition： -->
属性	含义
transition-property	指定使用过渡效果的css属性
transition-duration	设置过渡动画持续时间
transition-timing-function	设置动画的时间函数。
transition-delay	设置动画的延迟时间
transition:all应该是所有变化的属性都起效果，单独设置变化的属性就是只选择某属性添加transition效果，不加时间就相当于time=0,直接变化完了
https://juejin.cn/post/6970885478967050254

<!-- 7.router和route？ -->

https://blog.csdn.net/weixin_62277266/article/details/123067156
1. router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，包含了所有的路由包含了许多关键的对象和属性。例如history对象

$router.push({path:’/path’}); 本质是向history栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个history记录

$router.replace({path:’/path’}); 替换路由，没有历史记录

2. route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等

$route.path
字符串，等于当前路由对象的路径，会被解析为绝对路径，如 “/index/” 。

$route.params
对象，包含路由中的动态片段和全匹配片段的键值对

$route.query
对象，包含路由中查询参数的键值对。例如，对于 /index?id=1 ，会得到 $route.query.id == 1。



 <!-- scoped : -->
当 style 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。
慎用 scoped

https://juejin.cn/post/6898633179587215367
父组件无scoped属性，子组件带有scoped，父组件是无法操作子组件的样式的（原因在原理中可知），虽然我们可以在全局中通过该类标签的标签选择器设置样式，但会影响到其他组件
父组件有scoped属性，子组件无，父组件也无法设置子组件样式，因为父组件的所有标签都会带有data-v-469af010唯一标志，但子组件不会带有这个唯一标志属性，与1同理，虽然我们可以在全局中通过该类标签的标签选择器设置样式，但会影响到其他组件
父子组建都有，同理也无法设置样式，更改起来增加代码量

<component :is="item.icon"></component></el-icon>
<!-- is和component动态切换组件 

<!-- v-slot -->
https://www.cnblogs.com/chujunqiao/p/12272968.html

<!-- router-view和component :is的区别 -->
router-view
router-view是vueRouter的组件，主要是更新路由，可以不用跳转到一个新的页面，不会更新初始化函数mounted和created，只更新<router-view></router-view>标签下所渲染的组件。可以不用引入组件。

缺点
一个页面一个路由，跳转要写路由地址，更新tab样式要传参数

component :is=" "
component :is这个是vue的组件，is=要渲染的组件，不会更新路由，不会更新初始化函数mounted和created。刷新页面后会跳回默认显示页面；

缺点
需要引入所有要显示的组件，并且components:{声明}，



<!-- get和post -->


defineProps：
获取组件传值，类似vue2的props
和defineEmit和emit：
调用父组件的方法，先要发送到父组件在调用
和defineExpose:
暴露组件方法，父组件可以直接通过ref的方式调用子组件暴露的方法


<!-- watch的参数 -->
https://zhuanlan.zhihu.com/p/465651353#:~:text=VUE3%20%E4%BB%A3%E7%A0%81%EF%BC%9A%20watch%28nums%2C%20%28%29%20%3D%3E%20%7B%7D%29%20watch%28%28%29%20%3D%3E,%28%29%20%3D%3E%20%7B%7D%29%20%E5%85%B3%E4%BA%8E%20watch%20%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E9%99%A4%E4%BA%86%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%20deep%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%20immediate%E3%80%82
watch()函数接受三个参数
第一个参数是监听的目标对象：可以是函数返回值，可以是单个响应式数据，可以是多个响应式数据组成的数组
第二个参数是发生变化时要调用的回调函数：接受三个参数分别为新值、旧值、一个用于注册副作用清理的回调函数
第三个参数: 组件初始化时是否执行一次和是否进行深度监听：{ immediate: true, deep: true }

<!-- auto -->
margin-left: auto;本元素块右对齐
margin-right：auto 左对齐
margin:0 auto 居中
https://juejin.cn/post/7028579289758957576
width:auto:块级： width(包括padding)+margin=father:width+margin
内联：元素宽度由子元素的宽度决定。
height：auto 无论在块级还是内联都相似于内联


<!-- v-loading:一个自定义事件 -->

<!-- hash and history -->
https://juejin.cn/post/7116336664540086286
https://blog.csdn.net/sayoko06/article/details/85321802
<!-- 块级元素和内联元素 -->
https://blog.csdn.net/xuanfuhuo4769/article/details/81326457